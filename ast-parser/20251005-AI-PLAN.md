好的，這是一個將您現有的 `Java AST Parser` 專案升級為一個強大的「**程式碼知識圖譜引擎 (Code Knowledge Graph Engine)**」的詳細執行計畫。

此計畫分為四個主要階段，從基礎建設、核心功能開發，到 AI 智慧化整合，最後到產品化與運營，確保每一步都有明確的目標和交付成果。

---

### **執行總覽**

*   **目標**: 將靜態的 AST 解析結果，轉化為一個可互動、可查詢、並能由 AI 理解和利用的動態知識圖譜。
*   **核心技術**:
    *   **現有專案**: `01235711-javaparser` 作為程式碼解析與結構化資料來源。
    *   **圖資料庫**: **Neo4j** 用於儲存和查詢程式碼實體之間的複雜關係。
    *   **AI/LLM**: 大型語言模型 (如 GPT 系列) 作為自然語言理解與回答生成的核心。

---

### **階段一：基礎建設與概念驗證 (Proof of Concept) - 預計時程：1-2 週**

**目標**: 成功將現有 AST 解析結果導入本地 Neo4j 資料庫，並能手動執行基本的圖查詢，驗證核心概念的可行性。

| 任務編號 | 任務名稱 | 具體工作內容 | 交付成果 |
| :--- | :--- | :--- | :--- |
| **1.1** | **環境設定** | 1. 安裝 **Neo4j Desktop**，建立一個本地資料庫實例。<br>2. 在 `ast-parser` 專案的 `build.gradle` 中加入 Neo4j Java Driver 的依賴。 | - 可運行的本地 Neo4j 環境。<br>- 專案成功引入 Neo4j Driver。 |
| **1.2** | **圖譜模型設計 (V1)** | 定義第一版的核心圖譜模型，專注於最重要的關係：<br>- **節點**: `:Class`, `:Interface`, `:Method`<br>- **關係**: `EXTENDS`, `IMPLEMENTS`, `CALLS` | - 一份定義圖譜模型的 Markdown 文件。 |
| **1.3** | **開發 AST-to-Graph 轉換服務** | 1. 建立一個新服務 `AstToGraphService`。 <br>2. 該服務讀取 `FileSystemAstRepository` 產生的所有 AST JSON 檔案。<br>3. 遍歷 JSON 內容，將類別、方法、呼叫關係等轉換為 Cypher `MERGE` 語句。<br>4. 使用 Neo4j Driver 將 Cypher 語句發送到資料庫執行。 | - `AstToGraphService.java` 原始碼。<br>- 能夠將 AST 資料寫入 Neo4j 的核心邏輯。 |
| **1.4** | **建立批次導入腳本** | 1. 建立一個手動觸發的腳本或一個簡單的 API 端點。<br>2. 該腳本在 `AstParserService` 完成程式碼解析後，呼叫 `AstToGraphService` 執行完整的資料導入。 | - 一個 Gradle Task 或 shell 腳本，用於一鍵導入資料。 |
| **1.5** | **手動驗證與查詢** | 1. 執行批次導入腳本，將 `test-project` 的程式碼導入 Neo4j。<br>2. 打開 Neo4j Browser，手動編寫並執行 Cypher 查詢，例如：<br>   - `MATCH (m:Method)<-[:CALLS]-(c) WHERE m.name = 'getLevel2' RETURN c.fqn` (查找呼叫者)<br>   - `MATCH p=(c:Class)-[:EXTENDS|IMPLEMENTS*]->(parent) RETURN p` (查找繼承鏈) | - Neo4j 中成功建立的程式碼圖譜。<br>- 幾個成功執行的 Cypher 查詢範例及其結果截圖。 |

---

### **階段二：引擎核心功能開發 - 預計時程：2-3 週**

**目標**: 建立穩定的圖查詢 API，並豐富圖譜模型，使引擎具備對外服務的能力。

| 任務編號 | 任務名稱 | 具體工作內容 | 交付成果 |
| :--- | :--- | :--- | :--- |
| **2.1** | **豐富化圖譜模型 (V2)** | 擴展圖譜模型，加入更多細節：<br>- **節點**: 新增 `:Field`, `:Annotation`, `:Parameter`<br>- **關係**: 新增 `CONTAINS_METHOD`, `HAS_FIELD`, `INSTANTIATES`, `HAS_ANNOTATION` | - 更新後的圖譜模型設計文件。 |
| **2.2** | **開發圖查詢 API** | 1. 在 `AstParserController` 中建立一個新的 API 端點 `/api/graph/query`。<br>2. 請求體為 `{ "query": "MATCH (n) RETURN n LIMIT 10" }`。<br>3. 後端服務接收 Cypher 查詢，執行後將結果以 JSON 格式返回。 | - 一個功能完整的通用 Cypher 查詢 API。 |
| **2.3** | **建立預定義查詢庫** | 1. 建立一個 `GraphQueryLibraryService`。<br>2. 在其中封裝常用的 Cypher 查詢，例如：`findCallers(methodFqn)`, `findImplementations(interfaceFqn)`, `findUpstreamImpact(methodFqn)`。<br>3. 為這些常用查詢建立專屬的、更友好的 API 端點（例如 `/api/graph/find-callers`）。 | - 包含多個預定義查詢方法的服務。<br>- 幾個高層次的、易於使用的查詢 API。 |
| **2.4** | **整合進現有流程** | 1. 修改 `AstParserService` 的非同步解析流程。<br>2. 在 `parseSourceDirectoryAsync` 的 `CompletableFuture` 完成後，自動觸發 `AstToGraphService` 進行增量或全量更新。 | - 自動化的 AST 解析 -> 圖資料庫導入流程。 |

---

### **階段三：AI 整合與智慧化 - 預計時程：3-4 週**

**目標**: 引入大型語言模型 (LLM)，建立自然語言互動層，讓引擎能夠「聽懂」問題並「思考」答案。

| 任務編號 | 任務名稱 | 具體工作內容 | 交付成果 |
| :--- | :--- | :--- | :--- |
| **3.1** | **建立 AI 推理服務** | 1. 建立一個 `AiReasoningService`。<br>2. 該服務整合一個 LLM (例如透過 OpenAI API)。<br>3. 核心邏輯 (RAG): <br>   - **接收問題**: 接收來自使用者的自然語言問題。<br>   - **生成查詢**: LLM 根據問題，生成一個或多個 Cypher 查詢。<br>   - **執行查詢**: 呼叫階段二建立的圖查詢 API。 <br>   - **生成回答**: 將查詢結果作為上下文，連同原問題，交給 LLM 生成最終的自然語言回答。 | - `AiReasoningService.java`。<br>- 能夠將自然語言問題轉換為 Cypher 並生成回答的核心邏輯。 |
| **3.2** | **設計 Prompt Engineering 策略** | 1. 設計系統提示 (System Prompt)，告訴 LLM 它的角色是「程式碼知識圖譜專家」。<br>2. 提供清晰的指令，指導 LLM 如何根據用戶問題生成 Cypher。<br>3. 設計結果總結的提示，指導 LLM 如何將圖查詢的 JSON 結果轉化為人類可讀的洞察。 | - 一套用於 Cypher 生成和答案總結的 Prompt 範本。 |
| **3.3** | **建立聊天 API 端點** | 1. 在 `AstParserController` 或新的 `AiController` 中建立 `/api/ai/chat` 端點。<br>2. 該端點接收用戶的自然語言問題，呼叫 `AiReasoningService`，並將最終的回答返回。 | - 一個可以進行自然語言問答的聊天 API。 |
| **3.4** | **整合語義搜尋 (可選但推薦)** | 1. 建立 `EmbeddingService`，在 AST 解析後為方法和類別生成向量嵌入。<br>2. 建立 `/api/search/semantic` 端點，用於從自然語言找到最相關的程式碼 FQN。<br>3. 讓 `AiReasoningService` 在生成 Cypher 前，先呼叫語義搜尋來定位目標程式碼，提高準確性。 | - 語義搜尋 API。<br>- 更智能的 AI 推理流程。 |

---

### **階段四：產品化與持續運營 - 預計時程：持續進行**

**目標**: 提供一個穩定、易用的使用者介面，並建立監控和迭代機制，使引擎成為一個可靠的產品。

| 任務編號 | 任務名稱 | 具體工作內容 | 交付成果 |
| :--- | :--- | :--- | :--- |
| **4.1** | **開發使用者介面 (UI)** | 1. 建立一個簡單的前端應用 (例如使用 React 或 Vue)。<br>2. UI 包含一個聊天輸入框和一個結果顯示區。<br>3. 結果顯示區需要支援 Markdown 格式，以便呈現程式碼塊、列表和圖表 (Mermaid.js)。 | - 一個可供 BA, SA, Dev, SD 使用的 Web 介面。 |
| **4.2** | **部署與維運 (DevOps)** | 1. 將 `ast-parser` 應用和 Neo4j 資料庫容器化 (使用 Docker)。<br>2. 建立 CI/CD pipeline，自動化測試和部署流程。<br>3. 設定日誌監控和警報 (例如使用 ELK Stack 或 Grafana)。 | - Docker Compose 或 Kubernetes 部署文件。<br>- 一套完整的 CI/CD 與監控方案。 |
| **4.3** | **效能監控與優化** | 1. 監控 Neo4j 的查詢效能，對慢查詢建立索引。<br>2. 為常用的 API 查詢結果增加快取層 (例如 Redis)。 | - 優化後的 Cypher 查詢。<br>- 系統效能監控儀表板。 |
| **4.4** | **建立回饋與迭代機制** | 1. 在 UI 中增加一個「讚/倒讚」或意見回饋按鈕。<br>2. 定期收集使用者回饋和錯誤的回答，用於微調 Prompt 或優化圖譜模型。 | - 一個持續改進 AI Agent 準確性的閉環流程。 |

---

### **所需技能與資源**

*   **Java / Spring Boot**: 專案核心，需要精通。
*   **圖資料庫 / Neo4j / Cypher**: 需要學習和掌握 Neo4j 的基本操作和 Cypher 查詢語言。
*   **AI / LLM / Prompt Engineering**: 需要了解如何與大型語言模型互動，並設計有效的提示。
*   **前端開發 (React/Vue)**: 開發使用者介面所需。
*   **DevOps (Docker/CI/CD)**: 專案部署和維運所需。

這個執行計畫將您的工具轉化為一個智慧化的平台，能夠極大地提升團隊對複雜程式碼庫的理解深度和工作效率。