// ast-parser/build.gradle
plugins {
    id 'application' // Only this project needs to be runnable
}

dependencies {
    // Apache Commons Lang for String manipulation
    implementation 'org.apache.commons:commons-lang3:3.12.0'

    // Eclipse JDT Core for AST parsing
    implementation 'org.eclipse.jdt:org.eclipse.jdt.core:3.42.0' // Use a recent version, check Maven Central

    // Jackson for JSON serialization
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.19.2' // Use a recent version

    // Logging with logback-classic as SLF4J backend
    implementation 'org.slf4j:slf4j-api:2.0.9'
    implementation 'org.slf4j:jul-to-slf4j:2.0.9'
    implementation 'ch.qos.logback:logback-classic:1.4.14'

    implementation 'org.projectlombok:lombok:1.18.36'
    annotationProcessor 'org.projectlombok:lombok:1.18.36'
    
    testImplementation 'org.projectlombok:lombok:1.18.36'
    testAnnotationProcessor 'org.projectlombok:lombok:1.18.36'

    // Gradle Tooling API for testing
    implementation gradleApi()  // Uses the current Gradle version
}

application {
    mainClass = 'kai.javaparser.AstParserApp'
}

tasks.jar {
    // === START OF MODIFICATION ===
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE // <-- Add this line to handle duplicates

    // Optional: You can also explicitly exclude specific files that commonly cause conflicts
    // from {
    //     configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    // } {
    //     exclude 'META-INF/*.DSA' // Java signature files
    //     exclude 'META-INF/*.SF'  // Java signature files
    //     exclude 'META-INF/*.RSA' // Java signature files
    //     exclude 'META-INF/LICENSE' // Already handled by duplicatesStrategy, but can be explicit
    //     exclude 'META-INF/NOTICE'
    //     // If you have other specific files causing issues, add them here
    // }
    // === END OF MODIFICATION ===


    manifest {
        attributes 'Main-Class': 'kai.javaparser.AstParserApp'
    }
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
}
